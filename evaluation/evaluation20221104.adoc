:icons: font
:imagesdir: common/img/
:docinfodir: common/meta/
:linkcss: asciidoctor.css
:docinfo1:
// In generated HTML this is transformed
// to <meta name="description" content="..."/>
:description: Sample document with custom header and footer parts.
// In generated HTML this is transformed
// to <meta name="keywords" content="..."/>
:keywords: Asciidoctor, header, footer, docinfo

= Technologie-Evaluierung von Drehgebern und deren Anbindung an eine Java-basierte Potiboard-App
Achim Bloch-Späth <a.bloch-spaeth@gsi.de>, Martin Stein <m.stein@gsi.de>
Rev. 1.1, November 9, 2022
:toc:

<<<

== Einbindung dieser Arbeit in das laufende projekt FCC Digital Potiboard


Die hier beschriebene Technologie-Evaluierung dient als Grundlage zur Entscheidungsfindung zu den in der <<figure-1, Abbildung: Status FCC Digital Potiboard >> markierten _Major Milestones_ und __Subprojects / Tasks__.

[[figure-1]]
.Status FCC Digital Potiboard
image::potiboard-status-20220708.png[Status-Project, align="center"]

== Rückblick und Motivation

Der vor ca. 6 Jahren entwickelte Potiboard-Prototyp wurde in einem der vergangenen Potiboard-Meetings als unzureichend in seiner Technologieauswahl eingestuft.
Insbesondere der Einsatz einer "closed source library" des benutzten Phidget-Mikrocontroller, der zur Verarbeitung der Encodersignale dient, wurde kritisiert.
Dessen Treiber läuft zudem nicht im "Userspace" auf dem zu benutzenden Linuxderivat, was aus system-administrativer Sicht ein Nachteil ist.

Eine weitere Anforderung der Zukunft (FCC) **könnte sein**, dass die Drehgeber ihre Inkremente an eine Potiboard-App über eine nicht unerhebliche Entfernung übermittelt werden müssen.
Diese Anforderung wurde beim <<figure-1, alten Potiboard-Prototyp>> über eine hohe Integration der beteiligten Komponenten gelöst.
Drehgeber wie Potiboard-App, gesteuert über einen Touchscreen, befanden sich in einem Gehäuse mit Netzwerkanschluss.

[[figure-2]]
image::old-potiboard-prototype.png[Old potiboard prototype,align="center"]

== Skizze des neuen Potiboard-Encoder-Device
[[figure-22]]
image::potiboard-skizze.png[Old potiboard prototype,align="center"]

.Funktionsüberblick aus der Spezifikation
[quote, Spezifikation: F-FO-CMD-en-0009_DS_Potiboard_v4_inprogress.docx]
____
* Button functions are:
    • scroll back and forth (per button press by 4 devices to the right or left. In case of individual assignment, move one device to the right or left)
    • deactivate the encoders (deactivation deselects all devices and triggers the LSA data supply)
    • change the parameter view => volts, BRHO et cetera
    • activate and deactivate the master mode (first partner knob controls both devices, second (third, fourth) partner is ignored
    • change the increment
____


== Vom alten Potiboard-Prototyp übernommende Technologieentscheidungen und neue Wege

* Optische "Rotary Quadrature Encoder" wurden wieder wegen ihrer Signalqualität, Zuverlässigkeit und Verfügbarkeit eingesetzt. Auf kugelgelagerte Modelle wurde diesmal verzichtet (Haptikgründe wegen zu hoher Leichtgängigkeit).Merkmale sind 16-128 Pulse pro 360-Rotation, keine Zahnung, 5 V. 3.3V Modelle waren auf dem Markt nicht erhältlich.
** Beispiel-Encoder sind:
*** Grayhill 63R128, Stückpreis: 100 $ 
*** Bourns ENA1J-B28-L00128L, Stückpreis:60 $ 

Durch den Einsatz von modernen Mikrocontrollern, deren Spannung an ihren I/O Kanälen häufig auf 3,3 V limitiert ist (anstatt 5V), schränkt sich dich Auswahl der möglichen Endcoder-Modelle deutlich ein. Eventuell müssten die Encoder-Ausgangsspannungen an den Eingängen der Mikrocontroller mit Pegelumsetzern (Level-Shifter) angepasst werden, wenn 5 V Encoder-Modelle eingesetzt werden müssen.

* Es wurden wieder Mikrokontroller evaluiert, die die Inkremente der bis zu acht (8!) Encoder, ohne spürbare Zeitverzögerung, weiterverarbeiten können sollen. Statt des im alten Prototypen verwendeten Phidget-Mikrocontroller (1047) wurden folgende Mikrocontroller stattdessen betrachtet:
** Raspberry Pi 4, Stückpreis: 70 $
** STM32H7, STM32F7, Stückpreis: 70 $
** Teensy 4.1 (Arduino kompatibel), Stückpreis: 40 $
** Raspberry Pi Pico, Stückpreis: 8 $


Alle Systeme stellen nachbaubare Hardware dar (Ersatzteilversorgung scheint gesichert) und lassen sich mit Open-Source Software betreiben. Pro Einheit bewegen sie sich in einem Kostenrahmen von 6-80 US $.
Der Mikrocontroller-Code zur Weiterverarbeitung der Encoder-Inkremente muss bzw. musste in C, Python oder Assembler geschrieben und gewartet werden. Das gleiche gilt für die verschiedenen Übertragungtechnologien zur Java-basierten Potiboard-Applikation. 

== Generelle Hardware-Komponenten-Architekturüberlegungen

=== Komponentengruppen

[[figure-3]]
image::general-topology.svg[Generelle Komponenten, align="center"]


=== Inkrementzähler-Übertragung über Netzwerk oder USB

[cols=">a,<a", frame=none, grid=none]
|===
| image::komponenten-uml-02.svg[Network]
| image::komponenten-uml-03.svg[USB]
|===


.USB Nachteil
CAUTION: USB ist auf eine *maximale Kabellänge* von 5m spezifiziert. Mit guten Kabel und/oder Repeatern sind vielleicht bis zu 10m möglich.

.USB Vorteil
NOTE: USB ist prinzipiell schneller, die Protokolle haben keinen Adressierungs-Overhead.
Vieles ist dadurch einfacher, z.B. müssen Sender (Potiboard) und Empfängeradresse (Potiboard-App) nicht konfigurierbar programmiert werden.

.USB Vorteil
NOTE: USB liefert out of the box ausreichend Strom für Drehgeber und Mikroprozessor. Beim Netzwerk müßte zusätzliche Hardware (z.B. PoE) hinzugefügt werden, wenn ein Stromnetz-Anschluss vermieden werden soll (USB als nur zum Stromanschluss ginge natürlich auch). 

== Netzwerkbasierte System-Architekturen und Technologien

=== Testsystem mit der Technologie Spring Webflux

[[figure-4]]
.UML-Komponenten Diagram Network Connection with Spring Webflux
image::komponenten-uml-01.svg[New Reference Implementation, align="center"]


[[figure-5]]
.Test-Implementation 1
image::potiboard_network_01.svg[Reference Implementation Network,align="center"]

Es wurde ein Referenzsystem, wie im oberen Bild dargestellt, auf Basis eines Teensy 4.1 Mikrocontrollers entwickelt, der die Inkremente der Encoder in hoher Geschwindigkeit bis in eine Beispiel-JavaFX-Applikation weiterreicht.
====
Die im Referenzsystem eingesetzte Datenübermittlungstechnologie basiert auf der Technologie `Spring Webflux` und dem "Reactive Toolkit" `Project Reactor`. Sie wurde ausgewählt, da sie der "GSI Controls Applicationsservice-Technologieauswahl" entspricht, die für die Operating-Applikationen im FCC und HKR eingesetzt werden soll und teilweise schon eingesetzt wird.
====

Ein Nachteil und in mancherlei Hinsicht sicher auch Vorteil dieser Architektur ist die Einführung eines java-basierten (Spring-) Webflux-Servers (siehe Bild `EncoderPositionsServerPC`), der ein PC-System mit Controls-konformen OS sein sollte. Es ist also eine Schicht (`Tier`) notwendig, um die Inkremente der verschiedenen Encoder im `WebFlux`-Format zu versenden.

Auf der Habenseite dieser Architektur steht die Anpassbarkeit und Wartbarkeit nach den Richtlinien der Controls-Abteilung und damit eine sichere, kontrollierbare Netzwerkkommunikation im ACC-Netzwerk auf lange Sicht und keine Insellösung im ACC-Netz.

Eine vereinfachte Architektur könnte den Einsatz eines weiteren Rechners, wie der des Konzentrator-PCs, eingesetzt für als `Webflux`-Server, überflüssig machen. Die Instandhaltung des Rechners so wie die Wartung des Betriebssytems (z.B. Rocky Linux) erzeugt wiederkehrende Kosten. Deshalb wurden weitere netzwerk-basierte Technologien in Betracht gezogen.

=== Testsysteme mit den Technologien ZeroMQ und MQTT

[[figure-6]]
.Test-Implementation 2
image:potiboard_network_02.svg[Simpler Network and System Architecture, align="center"]

Ein Kanditat für eine einfachere Architektur ist zum Beispiel die Technologie `ZeroMQ`, die sich mit einem Raspberry Pi 4, wie getestet, leicht einsetzen läßt.

Sehr interessant ist auch die `MQTT`-Technologie, die allerdings die Notwendigkeit des Aufsetzens eines `MQTT`-Servers nach sich ziehen würde und somit den Vorteil der Kostenersparnis zumindestens teilweise wieder verliert.

== USB-basierte System-Architekturen und Technologien

=== Testsystem mit der Technologie USB-Serial


=== Testsystem mit der Technologie USB-HID


=== Testsystem mit der Technologie USB-MIDI



== Grundlegende zentrale Anforderungen (Stichwortliste)

====
[%interactive]
* [*] Komplexität, Lebensdauer und Wartbarkeit Hardware

Die Funktion der eingesetzten Drehgeber und Mirkocontroller muss durch Verfügbarkeit am Markt oder durch Reserveteile-Einlagerung für möglichst mehrere Jahrzehnte mit finanziell überschaubarem Aufwand absicherbar sein. Komplexe Systeme oder eine hohe Anzahl von verschiedenen benötigten Hardwarekomponenten sollte wenn möglich vermieden werden. 
====
====
[%interactive]
* [*] Komplexität, Lebensdauer und Wartbarkeit Software

Die eingesetzte Software auf Mikrocontroller und auf Potiboard-Applikationsseite sollte aus möglichst gut gepflegten und verständlichen Open-Source Projekten mit hoher Verbreitung stammen. Dies kann auch Auswirkungen auf die Wahl des Mikrocontrollers haben. Der notwendige selbst geschriebene Soure-Code sollte möglichst einfach wartbar sein. Auf dem Mikrocontroller kommen die Programmiersprachen Assembler, C und Python in Frage, auf der Potiboard-Applikationsseite werden Java-basierte Lösungen preferiert.  
====
====
[%interactive]
* [*] **Administration**s-, Konfigurationsaufwand

Der Aufwand für zusätzliche Hardware und Software, wie z.B. der KonzentratorPC für `Webflux` oder ein `MQTT-Server`(Linux-Administration, Hardwarepflege) oder zusätzliche Stromversorgungswege als auch der Aufwand für Konfigurationen (Netzwerk-Adressen-Pflege) sollte minimal gehalten werden. Unter diesen Punkt fallen auch notwendige Linux-Anpassungen z.B. auf den tcl100 Rechnern für den HKR.
====
====
[%interactive]
* [*] **Geschwindigkeit** Signalübertragung der Inkremente der Encoder

Die vom Nutzer über den Drehgeber zum Mikrocontroller und dann in das Java-Programm sollte zwischen max. bei 10 ms (100 Hz) liegen, besser deutlich niedriger.
====
====
[%interactive]
* [*] **Duplex**-Signalübertragung, nicht nur für die Inkremente der Encoder in eine Richtung, sondern auch in der Gegenrichtung von der Portiboard-App zurück zum Potiboard-Encoder-Device. 

Um die Benutzererfahrung am Potiboard-Encoder-Device zu verbessern, sollte es technisch möglich sein, Informationen wie Status der Verbindung, oder auch Magnet-Nomenklaturen an das Potiboard-Encoder-Device zu übertragen.
====


== Tabelle Technologiebewertung

.Versuch der Einordnung der Stärken und Schwächen der verschiedenen Technologien
[%header%footer, cols="h,l,l,l,l,l,l,l,l",width="100%"]
|====================
|Eigenschaft
--
Technologie|USB|Netzwerk|Hardware|Software|Administration|Geschwindigkeit|Duplex| &sum; *
|Webflux    | |X|*  |** |*  |** |***|  9
|MQTT       | |X|*  |*  |*  |** |***|  8
|ZeroMQ     | |X|** |** |** |** |***| 11
|Socket     | |X|** |**  |** |***|** | 11
|USB-Serial |X| |***|***|** |***|** | 13
|USB-HID    |X| |***|** |** |** |** | 11
|USB-MIDI   |X| |***|***|***|*  |*  | 11
|RS232/RS485| | |   |   |-  |   |   |
|MIDI (DIN) | | |   |   |-  |   |   |
| 8+|X = gehört zu, - = ungenügend, * = ausreichend , ** = gut, *** = sehr gut    |
|====================

Die Tabelle dient nur als Diskussionsgrundlage für die verschiedenen Technologien. Für einen Vergleich wären die verschiedenen Eigenschaften (Spalten) zu gewichten. Die &sum; * Spalte dient nicht der objektiven Bewertung;

== Fazit

Wenn USB als Datenübertragungssystem für Potiboard-Prototypentwickungen vorerst als ausreichend bewertet wird, wäre der technische Vorschlag, für den ersten Protoypen die Encoder-Signale mit einem Arduino kompatiblen Mikrocontroller der Art Teensy 4.1 zu verarbeiten und von diesem aus die Inkrementzählerwerte über das USB-MIDI-Protokoll an die java-basierte Potiboard-Applikation weiterzuleiten.

IMPORTANT: Der Teensy 4.1 ist ein kosteneffizienter, gut verfügbarer und hoch performanter 600 MHz ARM Cortex M7 Mikrocontroller. Seine über die Arduino-IDE leicht einbindbaren Open-Source Bibliotheken sind verbreitet und gut unterstützt Die in den Tests eingesetzten Bibiotheken für Encoder sowie die USB-Serial-, USB-HID- und USB-Midi Bibliotheken funktionierten schnell und problemlos.

IMPORTANT: Das USB-Midi Protokoll bietet als einzige USB-Datenübertragungstechnologie echtes Plug-and-Play an einem Linux-basierten Host (wie z.B. TCL100).
Auf der Java-Seite, also bei der Entwicklung und Wartung der Potiboard-Applikation, wird MIDI direkt von der `JRE` unterstützt durch die `Java Sound API`. D.h. es werden wahrscheinlich nie zusätzliche Bibliotheken oder Abhängigkeiten einzubinden sein.
Diesen Vorteilen stehen gegenüber eine leicht erhöhte Komplexität bei der Programmierung der Übertragungsdatenpakete und eine niedrigere aber noch ausreichende Datenübertragungsrate.

Wenn USB als Datenübertragungssystem als möglicherweise nicht ausreichend bewertet wird, müsste die Evaluierung der netzwerk-basierten Technologien weitergeführt werden.
Eine rein _socket-basierte_ Verbindung von einem netzwerk-fähigen Mikrocontroller zur java-basierten Potiboard-Applikation wäre ein begehbarer Weg oder eine auf das _ZeroMQ-Messaging_ basierende Übertragung zwischen Mikrokontroller und der Potiboard-Applikation..


== Annex

** GPS-System zur Uhrensynchronisation für Zeitmessungen mit ~  30 &#181;s Genauigkeit  
** 7-Bit Arithmetische Kodierung zur Darstellung von Datentypengrößen größer als 7 Bit (>127) (MIDI-Anforderung)
** Nutzung Statusregister für GPIO zur Vermeidung von CPU-Interrupts beim Raspberry PI Nano





